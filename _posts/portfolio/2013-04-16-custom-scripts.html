---
title: "Custom Scripts"
description: ""
date: 2013-04-16 00:09:45
category: portfolio
pagination_enabled: false
layout: portfolio-page
tags: [web]
---

<!-- START OF PROJECT -->
<div id="{{ page.title | downcase |  replace:' ','-' }}">

<!-- INTRO -->
<div class="row-fluid">
  <div class="span12">
    <div class="project-intro">
      <h1>{{ page.title }}</h1>
      <p class="lead">
      <span class="muted">Here are a few scripts I have written for various applications.</span>
      </p>
      
      <div class="cover-image">
        <img src="/img/screenshots/vim.png" alt="Vim screenshot of 3 source files and NERDTree." />
      </div>
    </div>
  </div>
</div>


<!-- CODE SNIPPET -->
<div class="row-fluid project-container">
  <div class="span12">
    <div class="project-code">
      <h2>Ruby Blog Comment Generator for Jekyll</h2>
      
      <p class="lead">
        This is a Jekyll plugin I wrote for publishing comments to the <a href="/"><b>blog</b></a>. It takes comments from a predefined directory and attaches them to the post it is associated with.
      </p>
      
      <div class="code-sample">
        
{% highlight ruby linenos %}

module Jekyll

  class CommentGenerator < Generator

    safe true

    # Generate commented pages. Loops through each post and attaches a comment
    # array containing Hashes. One comment array per post.
    #
    # site - The Site.
    #
    # Returns nothing.
    def generate(site)
      site.posts.dup.each do |post|
        # This might seem redundant, but this helps ensure that no matter which case may
        # occur, comments_enabled will always have some valid value.
        post.data['comments_enabled'] = comments_enabled?(site.config, post.data['comments_enabled'])
        
        if post.data['comments_enabled'] == true || post.data['comments_enabled'] == 1
          attach_comments(site, post)
        end
      end
    end
    
    # Determines whether or not comments are enabled for a particular
    # post. The default state (if a post doesn't explicitly define it's
    # individual comment boolean) is determined by the _config file.
    #
    # config - The configuration Hash. Used for the site-wide default for
    #          comments_enabled
    # comments_enabled - The Boolean for whether or not comments are enabled.
    #                    This is set in the comment's file.
    #
    # Returns true if comments are enabled for this post, false otherwise.
    def comments_enabled?(config, comments_enabled)
      # Check if the post's comment_enabled variable was defined. If so,
      # it takes precedence.
      if comments_enabled.nil?
        # If comments_enabled is NOT defined, get the value from the
        # config file.
        if config['comments_enabled'].nil?
          # If the config file isn't defined, we default to off.
          return false;
        else
          return config['comments_enabled']
        end
      else
        return comments_enabled
      end
    end
    
    # Attaches comments to it's corresponding blog post. This function
    # creates a comments array for an individual post object and makes
    # the array available to Liquid. Renders each comment's markdown
    # as well, based on the comment file's extension.
    #
    # site - The Site.
    # post - The post object for which we are generating comments.
    #
    # Returns nothing.
    def attach_comments(site, post)
      # Ensure a new set of comments every post iteration.
      @comments = []
      
      # Build a hash of comments for this particular post object.
      Dir.glob(File.join(site.source, '_comments') + "/**/*").sort_by! {|s| s[/\d+/].to_i}.each do |item|
        next if File.directory?(item)
        # do work on real items
        comment_hash = (self.read_comment_yaml(item, post, site))
        unless comment_hash.nil?
          @comments << comment_hash
        end
      end
      
      # Set "number of comments" variable and make it available to Liquid.
      comments_num = @comments.length
      post.data['comments_num'] = comments_num
      
      # Make the comments array available to Liquid.
      post.data['comments'] = @comments
    end
    
    # Reads the YAML frontmatter as well as the content below the
    # front-matter. Then, converts the markdown in the content.
    # Finally, creates a Hash containing all data for the current
    # comment iteration.
    #
    # item - The String filename of the file.
    # post - The post object for which we are generating comments.
    # site - The Site.
    #
    # Returns a Hash containing all data of the current comment
    # iteration.
    def read_comment_yaml(item, post, site)
      comment_content = File.read(item)
      
      begin
        if comment_content =~ /\A(---\s*\n.*?\n?)^(---\s*$\n?)/m
          comment_content = $POSTMATCH
          comment_data = YAML.load($1)
        end
      rescue => e
      end

      if comment_data['post_id'] == post.id
        post_comments = comment_data
        converter_instance = converter(item, site)
        post_comments['comment'] = converter_instance.convert(comment_content)
      end
      
      post_comments
    end
    
    # Determines which converter to use based on the file's extension.
    #
    # item - The name of the file containing the comment.
    # Site - The Site.
    #
    # Returns the Converter instance.
    def converter(item, site)
      ext = File.extname(item)
      @converter ||= site.converters.find { |c| c.matches(ext) }
    end
  end

end

{% endhighlight %}

      </div>
    </div>
  </div>
</div>


<!-- CODE SNIPPET -->
<div class="row-fluid project-container">
  <div class="span12">
    <div class="project-code">
      <h2>PHP Process Handler for Redcarpet</h2>
      
      <p class="lead">
        Readers of the site can leave comments on any blog post. Blog comments support the use of markdown. This means readers can stylize their comments however they'd like. In order to assist readers using markdown, I implemented a preview function in the comment form. It runs the comment through Redcarpet, a markdown processor written in Ruby. The following is a portion of the PHP code which spawns and handles the Redcarpet process.
      </p>
      
      <div class="code-sample">
        
{% highlight php linenos startinline %}

// Cache the raw markdown for backup-purposes (in case there is ever a future
// situation where we want to rebuild all comments from scratch).
$data['markdown'] = $data['comment'];
 
// Build the descriptor spec for running an external process.
$descriptorspec = array(
 0 => array("pipe", "r"),  // STDIN is a pipe that the child will read from
 1 => array("pipe", "w"),  // STDOUT is a pipe that the child will write to
 2 => array("pipe", "w")   // STDERR is a pipe that the child will write to
);

// Start the process.
$process = proc_open('ruby ./bs-forms.rb', $descriptorspec, $pipes);
$return_value = -1;
if (is_resource($process)) {
  // $pipes now looks like this:
  // 0 => writeable handle connected to child STDIN
  // 1 => readable handle connected to child STDOUT
  // 2 => writeable handle connected to child STDERR

  // Write the comment to STDIN.
  fwrite($pipes[0], $data['comment']);
  // Close the STDIN pipe.
  fclose($pipes[0]);

  // Read from STDOUT and store the output locally.
  $data['comment'] = stream_get_contents($pipes[1]);
  // Close the STDOUT pipe.
  fclose($pipes[1]);
  
  // Read from STDERR and store the output locally.
  $pipe_error = stream_get_contents($pipes[2]);
  // Close the STDERR pipe.
  fclose($pipes[2]);

  // It is important that you close any pipes before calling
  // proc_close in order to avoid a deadlock
  
  // This is the exit RV. NOT RELIABLE (the RV will be -1 if the application
  // exited on its own before this call).
  $return_value = proc_close($process);
  
  // Update the return value based on whether the application itself
  // wrote to STDERR.
  if (!empty($pipe_error)) {
    $return_value = -1;
  }
  else {
    $return_value = 0;
  }
}

{% endhighlight %}

        
      </div>
    </div>
  </div>
</div>

<!-- CODE SNIPPET -->
<div class="row-fluid project-container">
  <div class="span12">
    <div class="project-code">
      <h2>Liquid Templating for HTML</h2>
      
      <p class="lead">
        This site is statically generated. <a href="https://github.com/Shopify/liquid/"><b>Liquid markup</b></a> is used to help in site generation. Here is a sample implementation of how the blog index page is generated.
      </p>
      
      <div class="code-sample">
        
{% highlight html linenos %}
{% raw %}
{% for post in site.categories.blog limit:site.recent_posts %}
<div class="blogbody">
  <article>
    <header>
      <h2 class="title"><a href="{{ post.url }}/" class="title-link">{{ post.title }}</a></h2>
      <h3 class="date"><time datetime="{{ post.date | date_to_xmlschema }}">{{ post.date | date: "%B %d, %Y" }}</time></h3>
    </header>
      
      {% if post.description %}
        {{ post.description }}
      {% else %}
        {% if post.excerpt %}
          {{ post.excerpt }}
        {% else %}
          {{ post.content }}
        {% endif %}
      {%endif %}
      <p class="more-link"><a href="{{ post.url }}/">Read Article &#8594;</a></p>
    
    <footer>
      <!-- Author Information -->
      <div class="posted muted">
        Published by Byron Sanchez
        {% if post.comments_enabled %}
          &nbsp;&nbsp;|&nbsp;&nbsp;
          <a href="{{ post.url }}/#comments">
            {% case post.comments_num %}
              {% when 0 %}
                No Comments
              {% when 1 %}
                1 Comment
              {% else %}
                {{post.comments_num}} Comments
            {% endcase %}
          </a>
        {% endif %}
      </div>
    </footer>
  </article>
</div>
{% endfor %}
{% endraw %}
{% endhighlight %}
        
      </div>
    </div>
  </div>
</div>


<!-- OUTRO -->
<div class="row-fluid project-outro-container">
  <div class="span12">
    <div class="project-outro">
    <h2>Custom Scripts</h2>
    <p>I have a collection of different scripts I use for different parts of my work. I am considering putting them up on GitHub. I would have to clean them up and generalize them a bit before uploading them. <a href="https://github.com/byronsanchez"><b>Keep an eye out, and maybe you'll find something useful there.</b></a></p>
    </div>
  </div>  
</div>

</div> <!-- /END DIV ID -->

<!-- /END OF PROJECT -->
